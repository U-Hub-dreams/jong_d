<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>éº»é›€Webï¼ˆ4äººæ‰“ã¡ãƒ»å¼·CPUãƒ»æœ€å–„æ‰‹è¡¨ç¤ºï¼‰</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --panel2:#0f1730;
      --text:#e7ecff;
      --muted:#a9b4de;
      --accent:#6ee7ff;
      --good:#67e8a7;
      --warn:#fbbf24;
      --bad:#fb7185;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius:16px;
      --tile:#f8fafc;
      --tileText:#0b1220;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 0%, #16244a 0%, var(--bg) 50%, #070b14 100%);
      color:var(--text);
    }
    header{
      padding:16px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      position: sticky; top:0; z-index:10;
      backdrop-filter: blur(10px);
    }
    header h1{
      margin:0;
      font-size:16px;
      letter-spacing:.02em;
      display:flex; gap:10px; align-items:center;
    }
    header .badge{
      font-size:12px;
      color:var(--bg);
      background:var(--accent);
      padding:3px 10px;
      border-radius:999px;
      font-weight:700;
    }
    main{
      max-width:1100px;
      margin:0 auto;
      padding:16px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:12px 14px;
      font-size:13px;
      color:var(--muted);
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      background: rgba(0,0,0,.12);
    }
    .card .body{
      padding:12px 14px;
    }
    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    button{
      appearance:none;
      border:none;
      background: rgba(255,255,255,.10);
      color: var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.02em;
      transition: transform .05s ease, background .2s ease;
    }
    button:hover{background: rgba(255,255,255,.16)}
    button:active{transform: translateY(1px)}
    button.primary{background: rgba(110,231,255,.22); border:1px solid rgba(110,231,255,.35)}
    button.primary:hover{background: rgba(110,231,255,.28)}
    button.danger{background: rgba(251,113,133,.18); border:1px solid rgba(251,113,133,.28)}
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.07);
      border:1px solid var(--line);
      color: var(--muted);
      font-size:12px;
    }
    .pill strong{color:var(--text)}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .muted{color:var(--muted); font-size:12px; line-height:1.55}
    .log{
      height: 220px;
      overflow:auto;
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px;
      background: rgba(0,0,0,.18);
      font-size:12px;
      line-height:1.55;
      color: var(--muted);
    }
    .log b{color:var(--text)}
    .players{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .pbox{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.14);
      padding:10px;
    }
    .pname{display:flex; align-items:center; justify-content:space-between; font-weight:800; font-size:13px}
    .river{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px}
    .tile{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:34px;
      padding:7px 8px;
      border-radius: 12px;
      background: var(--tile);
      color: var(--tileText);
      border:1px solid rgba(0,0,0,.10);
      font-weight:900;
      box-shadow: 0 4px 10px rgba(0,0,0,.12);
      user-select:none;
      line-height:1;
    }
    .tile.small{
      min-width:28px;
      padding:6px 7px;
      border-radius: 11px;
      font-size:16px;
    }
    .tile.clickable{cursor:pointer}
    .tile.clickable:hover{filter: brightness(0.97)}
    .tile.best{outline: 3px solid rgba(103,232,167,.8)}
    .tile.badge2{outline: 3px solid rgba(251,191,36,.8)}
    .hand{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;
    }
    .suggest{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.16);
      padding:10px;
    }
    .sitem{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 6px;
      border-bottom:1px dashed rgba(255,255,255,.12);
      gap:12px;
      font-size:12px;
    }
    .sitem:last-child{border-bottom:none}
    .sleft{display:flex; align-items:center; gap:10px}
    .smeta{color:var(--muted)}
    .status{
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.12);
      font-size:12px;
      color:var(--muted);
      line-height:1.6;
    }
    .status strong{color:var(--text)}
    .hint{
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.55;
    }
    input[type="range"]{width: 180px}
    label{font-size:12px; color:var(--muted)}
    .rightTop{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .tag{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--muted);
    }
  </style>
</head>
<body>
<header>
  <h1>
    éº»é›€Webï¼ˆ4äººæ‰“ã¡ï¼‰ <span class="badge">å¼·CPU + æœ€å–„æ‰‹è¡¨ç¤º</span>
    <span class="tag">é³´ã/å½¹/ç‚¹æ•°ãªã—ï¼ˆå’Œäº†å½¢ã®ã¿ï¼‰</span>
  </h1>
</header>

<main>
  <section class="card">
    <h2>
      å¯¾å±€ç”»é¢
      <div class="rightTop">
        <span class="pill">å±±æ®‹ã‚Šï¼š<strong id="wallCount">-</strong></span>
        <span class="pill">æ‰‹ç•ªï¼š<strong id="turnWho">-</strong></span>
      </div>
    </h2>
    <div class="body">
      <div class="players" id="players"></div>

      <div style="height:10px"></div>
      <div class="status" id="statusBox">é–‹å§‹ãƒœã‚¿ãƒ³ã§é…ç‰Œã—ã¾ã™ã€‚</div>

      <div style="height:10px"></div>
      <div class="suggest">
        <div class="row" style="justify-content:space-between">
          <div style="font-weight:900">ã‚ãªãŸã®æ‰‹ç‰Œï¼ˆã‚¯ãƒªãƒƒã‚¯ã§æ‰“ç‰Œï¼‰</div>
          <div class="pill">ã‚·ãƒ£ãƒ³ãƒ†ãƒ³ï¼š<strong id="myShanten">-</strong></div>
        </div>
        <div class="hand" id="myHand"></div>
        <div class="hint">
          æœ€å–„æ‰‹ã¯ <b>ã€Œã‚·ãƒ£ãƒ³ãƒ†ãƒ³æœ€å° â†’ å—ã‘å…¥ã‚Œæœ€å¤§ï¼ˆæ®‹ã‚Šæšæ•°ï¼‰ã€</b> ã§æ±ºå®šã€‚ä¸Šä½å€™è£œã‚‚è¡¨ç¤ºã—ã¾ã™ã€‚
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="grid2">
        <div class="card" style="box-shadow:none">
          <h2>æœ€å–„æ‰‹ï¼ˆä¸Šä½å€™è£œï¼‰</h2>
          <div class="body" id="bestList"></div>
        </div>
        <div class="card" style="box-shadow:none">
          <h2>æ“ä½œ</h2>
          <div class="body">
            <div class="controls">
              <button class="primary" id="btnNew">æ–°è¦é–‹å§‹</button>
              <button id="btnStep">æ¬¡ã¸ï¼ˆ1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼‰</button>
              <button class="danger" id="btnAuto">è‡ªå‹•ï¼šOFF</button>
            </div>
            <div style="height:10px"></div>
            <div class="row">
              <label>è‡ªå‹•é€Ÿåº¦</label>
              <input type="range" id="speed" min="0" max="100" value="55" />
              <span class="pill">é…â†â†’é€Ÿ</span>
            </div>
            <div class="hint">
              è‡ªå‹•ONã«ã™ã‚‹ã¨ CPUæ‰‹ç•ªã¯è‡ªå‹•é€²è¡Œã€‚ã‚ãªãŸã®æ‰‹ç•ªã§åœæ­¢ã—ã¾ã™ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§æ‰“ç‰Œï¼‰ã€‚<br/>
              â€»å±±ãŒå°½ããŸã‚‰æµå±€ã€‚
            </div>
          </div>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="card" style="box-shadow:none">
        <h2>ãƒ­ã‚°</h2>
        <div class="body">
          <div class="log" id="log"></div>
        </div>
      </div>

    </div>
  </section>

  <aside class="card">
    <h2>èª¬æ˜ï¼ˆã“ã®ã‚¢ãƒ—ãƒªã®ã€Œæœ€å–„æ‰‹ã€ï¼‰</h2>
    <div class="body">
      <div class="muted">
        <b>æœ€å–„æ‰‹</b>ï¼šä»Šã®æ‰‹ç‰Œã‹ã‚‰1æšåˆ‡ã‚‹ã¨ãã€æ¬¡ã®å„ªå…ˆé †ä½ã§è©•ä¾¡ã—ã¾ã™ã€‚<br/><br/>
        1) <b>ã‚·ãƒ£ãƒ³ãƒ†ãƒ³æ•°ãŒæœ€å°</b>ï¼ˆå’Œäº†ã¾ã§ã®è·é›¢ãŒæœ€çŸ­ï¼‰<br/>
        2) åŒç‚¹ãªã‚‰ <b>å—ã‘å…¥ã‚Œæšæ•°ãŒæœ€å¤§</b>ï¼ˆæ¬¡ã«è‰¯ããªã‚‹ç‰Œã®æ®‹ã‚Šæšæ•°ã®åˆè¨ˆãŒæœ€å¤§ï¼‰<br/><br/>
        CPUã‚‚åŒã˜è©•ä¾¡ã§æ‰“ç‰Œã™ã‚‹ã®ã§ã€ç´ ç›´ã«å¼·ã„å‹•ãã«ãªã‚Šã¾ã™ã€‚<br/>
        å½¹ãƒ»ç‚¹æ•°ã¯æ‰±ã£ã¦ã„ãªã„ã®ã§ã€ç´”ç²‹ã«ã€Œæœ€é€Ÿã§ä¸ŠãŒã‚‹ã€æ–¹å‘ã®å¼·ã•ã§ã™ã€‚
      </div>
      <div style="height:12px"></div>
      <div class="muted">
        <b>å®Ÿè£…ã—ã¦ã„ã‚‹å’Œäº†å½¢</b><br/>
        ãƒ»ä¸€èˆ¬å½¢ï¼ˆ4é¢å­1é›€é ­ï¼‰<br/>
        ãƒ»ä¸ƒå¯¾å­<br/>
        ãƒ»å›½å£«ç„¡åŒ<br/><br/>
        <b>æœªå®Ÿè£…</b>ï¼šé³´ãã€ãƒªãƒ¼ãƒã€ãƒ‰ãƒ©ã€å½¹åˆ¤å®šã€ç‚¹æ•°ã€ãƒ•ãƒªãƒ†ãƒ³ç­‰
      </div>
    </div>
  </aside>
</main>

<script>
/** ===========================
 *  Tile model (0..33)
 *  0-8: 1m..9m
 *  9-17: 1p..9p
 *  18-26: 1s..9s
 *  27-33: æ± å— è¥¿ åŒ— ç™½ ç™¼ ä¸­
 * =========================== */

const TILE_UNI = [
  "ğŸ€‡","ğŸ€ˆ","ğŸ€‰","ğŸ€Š","ğŸ€‹","ğŸ€Œ","ğŸ€","ğŸ€","ğŸ€", // man
  "ğŸ€™","ğŸ€š","ğŸ€›","ğŸ€œ","ğŸ€","ğŸ€","ğŸ€Ÿ","ğŸ€ ","ğŸ€¡", // pin
  "ğŸ€","ğŸ€‘","ğŸ€’","ğŸ€“","ğŸ€”","ğŸ€•","ğŸ€–","ğŸ€—","ğŸ€˜", // sou
  "ğŸ€€","ğŸ€","ğŸ€‚","ğŸ€ƒ","ğŸ€†","ğŸ€…","ğŸ€„"            // honors
];
const TILE_NAME = (() => {
  const a=[];
  for(let i=0;i<9;i++) a.push(`${i+1}m`);
  for(let i=0;i<9;i++) a.push(`${i+1}p`);
  for(let i=0;i<9;i++) a.push(`${i+1}s`);
  a.push("æ±","å—","è¥¿","åŒ—","ç™½","ç™¼","ä¸­");
  return a;
})();

function tileToStr(t){ return TILE_UNI[t]; }
function tileToKey(t){ return TILE_NAME[t]; }

function countsFromTiles(tiles){
  const c = Array(34).fill(0);
  for(const t of tiles) c[t]++;
  return c;
}

function deepCopyCounts(c){ return c.slice(); }

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

/** ===========================
 *  Shanten (standard + chiitoi + kokushi)
 *  Reference-free implementation (DFS + memo)
 * =========================== */

function shantenAll(counts){
  // Minimum among (standard, chiitoi, kokushi)
  const sStd = shantenStandard(counts);
  const sChi = shantenChiitoi(counts);
  const sKok = shantenKokushi(counts);
  return Math.min(sStd, sChi, sKok);
}

function shantenChiitoi(counts){
  let pairs=0, unique=0;
  for(let i=0;i<34;i++){
    if(counts[i]>0) unique++;
    pairs += Math.floor(counts[i]/2);
  }
  // need 7 pairs
  // shanten = 6 - pairs + max(0, 7-unique)
  return 6 - pairs + Math.max(0, 7 - unique);
}

function shantenKokushi(counts){
  const yaochu = new Set([
    0,8, 9,17, 18,26, // 1&9 of suits
    27,28,29,30,31,32,33 // honors
  ]);
  let unique=0;
  let hasPair=false;
  for(const t of yaochu){
    if(counts[t]>0) unique++;
    if(counts[t]>=2) hasPair=true;
  }
  // need 13 uniques + one pair
  return 13 - unique - (hasPair ? 1 : 0);
}

/**
 * Standard shanten via DFS:
 * maximize (mentsu, taatsu, pair) then compute shanten = 8 - 2*mentsu - taatsu - pair,
 * with constraint mentsu+taatsu <= 4, etc.
 */
function shantenStandard(counts){
  const memo = new Map();
  let best = 8;

  // helper: trim to next index with any tiles
  function nextIndex(c, start){
    for(let i=start;i<34;i++) if(c[i]>0) return i;
    return 34;
  }

  function keyOf(c, idx, m, t, p){
    // compact key
    return idx + "|" + m + "|" + t + "|" + p + "|" + c.join("");
  }

  function consider(m, t, p){
    // clamp taatsu: m + t <= 4
    let tt = t;
    if(m + tt > 4) tt = 4 - m;
    if(tt < 0) tt = 0;
    const s = 8 - 2*m - tt - p;
    if(s < best) best = s;
  }

  function dfs(c, idx, mentsu, taatsu, pair){
    // pruning
    consider(mentsu, taatsu, pair);
    if(idx>=34) return;

    const k = keyOf(c, idx, mentsu, taatsu, pair);
    if(memo.has(k)) return;
    memo.set(k, true);

    idx = nextIndex(c, idx);
    if(idx>=34){
      consider(mentsu, taatsu, pair);
      return;
    }

    // Option: skip this tile (treat as isolated)
    // remove one and continue
    c[idx]--;
    dfs(c, idx, mentsu, taatsu, pair);
    c[idx]++;

    // Try making sets involving idx

    // Triplet
    if(c[idx] >= 3){
      c[idx] -= 3;
      dfs(c, idx, mentsu+1, taatsu, pair);
      c[idx] += 3;
    }

    // Pair (as head or taatsu)
    if(c[idx] >= 2){
      c[idx] -= 2;
      if(pair === 0){
        dfs(c, idx, mentsu, taatsu, 1);
      }else{
        // already have head, count as taatsu
        dfs(c, idx, mentsu, taatsu+1, pair);
      }
      c[idx] += 2;
    }

    // Sequences (only suits)
    if(idx <= 26){
      const inSuit = idx % 9;
      // sequence idx,idx+1,idx+2 must be in same suit and within 1..7
      if(inSuit <= 6 && c[idx] > 0 && c[idx+1] > 0 && c[idx+2] > 0){
        c[idx]--; c[idx+1]--; c[idx+2]--;
        dfs(c, idx, mentsu+1, taatsu, pair);
        c[idx]++; c[idx+1]++; c[idx+2]++;
      }

      // taatsu: idx+1
      if(inSuit <= 7 && c[idx] > 0 && c[idx+1] > 0){
        c[idx]--; c[idx+1]--;
        dfs(c, idx, mentsu, taatsu+1, pair);
        c[idx]++; c[idx+1]++;
      }
      // taatsu: idx+2
      if(inSuit <= 6 && c[idx] > 0 && c[idx+2] > 0){
        c[idx]--; c[idx+2]--;
        dfs(c, idx, mentsu, taatsu+1, pair);
        c[idx]++; c[idx+2]++;
      }
    }
  }

  dfs(deepCopyCounts(counts), 0, 0, 0, 0);
  return best;
}

/** ===========================
 *  Ukeire (count of improving tiles)
 * =========================== */
function remainingCountsFromWall(wall){
  const c = Array(34).fill(0);
  for(const t of wall) c[t]++;
  return c;
}

function ukeireAfterDiscard(handCounts, remCounts){
  const cur = shantenAll(handCounts);
  let total = 0;
  // try drawing each tile
  for(let t=0;t<34;t++){
    if(remCounts[t] <= 0) continue;
    handCounts[t]++;
    const s = shantenAll(handCounts);
    handCounts[t]--;
    if(s < cur) total += remCounts[t];
  }
  return {cur, total};
}

/**
 * Evaluate discards for a hand (14 tiles typical in turn)
 * returns list: [{tile, shanten, ukeire}]
 */
function evaluateDiscards(tiles, remCounts){
  const counts = countsFromTiles(tiles);
  const results = [];
  const seen = new Set();
  for(const t of tiles){
    if(seen.has(t)) continue;
    seen.add(t);
    if(counts[t] <= 0) continue;
    counts[t]--;
    const s = shantenAll(counts);
    const u = ukeireAfterDiscard(counts, remCounts).total;
    results.push({tile:t, shanten:s, ukeire:u});
    counts[t]++;
  }
  results.sort((a,b)=>{
    if(a.shanten !== b.shanten) return a.shanten - b.shanten; // smaller better
    if(a.ukeire !== b.ukeire) return b.ukeire - a.ukeire;     // larger better
    return a.tile - b.tile;
  });
  return results;
}

/** ===========================
 *  Agari check (any of standard / chiitoi / kokushi)
 * =========================== */
function isAgari(counts){
  // completed if shanten == -1
  return shantenAll(counts) === -1;
}

/** ===========================
 *  Game engine (no calls)
 * =========================== */
const STATE = {
  wall: [],
  hands: [[],[],[],[]],
  rivers: [[],[],[],[]],
  turn: 0,
  ended: false,
  auto: false,
  waitingHuman: false,
};

const PLAYERS = [
  {name:"ã‚ãªãŸ", cpu:false},
  {name:"CPUâ‘ ", cpu:true},
  {name:"CPUâ‘¡", cpu:true},
  {name:"CPUâ‘¢", cpu:true},
];

const els = {
  players: document.getElementById("players"),
  wallCount: document.getElementById("wallCount"),
  turnWho: document.getElementById("turnWho"),
  statusBox: document.getElementById("statusBox"),
  myHand: document.getElementById("myHand"),
  myShanten: document.getElementById("myShanten"),
  bestList: document.getElementById("bestList"),
  log: document.getElementById("log"),
  btnNew: document.getElementById("btnNew"),
  btnStep: document.getElementById("btnStep"),
  btnAuto: document.getElementById("btnAuto"),
  speed: document.getElementById("speed"),
};

function msDelay(){
  // range 0..100 => 900..80ms
  const v = Number(els.speed.value);
  return Math.max(80, 900 - v*8.2);
}

function logLine(html){
  const div = document.createElement("div");
  div.innerHTML = html;
  els.log.appendChild(div);
  els.log.scrollTop = els.log.scrollHeight;
}

function setStatus(text){
  els.statusBox.innerHTML = text;
}

function renderPlayers(){
  els.players.innerHTML = "";
  for(let p=0;p<4;p++){
    const box = document.createElement("div");
    box.className = "pbox";
    const name = document.createElement("div");
    name.className = "pname";
    const left = document.createElement("div");
    left.textContent = PLAYERS[p].name;
    const right = document.createElement("div");
    right.innerHTML = `<span class="pill">æ‰‹ç‰Œ ${STATE.hands[p].length}</span>`;
    name.appendChild(left); name.appendChild(right);

    const river = document.createElement("div");
    river.className = "river";
    for(const t of STATE.rivers[p]){
      const s = document.createElement("span");
      s.className = "tile small";
      s.title = tileToKey(t);
      s.textContent = tileToStr(t);
      river.appendChild(s);
    }

    box.appendChild(name);
    const m = document.createElement("div");
    m.className = "muted";
    m.style.marginTop = "6px";
    m.textContent = (p===STATE.turn && !STATE.ended) ? "â–¶ æ‰‹ç•ª" : " ";
    box.appendChild(m);
    box.appendChild(river);
    els.players.appendChild(box);
  }
}

function renderTop(){
  els.wallCount.textContent = String(STATE.wall.length);
  els.turnWho.textContent = STATE.ended ? "çµ‚äº†" : PLAYERS[STATE.turn].name;
}

function sortHandTiles(tiles){
  tiles.sort((a,b)=>a-b);
}

function renderMyHand(){
  const me = 0;
  const tiles = STATE.hands[me].slice();
  sortHandTiles(tiles);

  const rem = remainingCountsFromWall(STATE.wall);
  // remove visible tiles from rem? (wall already excludes hands/rivers so OK)
  const evals = evaluateDiscards(tiles, rem);

  const myCounts = countsFromTiles(tiles);
  const mySh = shantenAll(myCounts);
  els.myShanten.textContent = (mySh>=0 ? String(mySh) : "å’Œäº†");

  // build best list
  els.bestList.innerHTML = "";
  if(evals.length){
    const top = evals.slice(0,6);
    for(let i=0;i<top.length;i++){
      const it = top[i];
      const row = document.createElement("div");
      row.className = "sitem";
      const left = document.createElement("div");
      left.className = "sleft";
      const tile = document.createElement("span");
      tile.className = "tile small " + (i===0 ? "best" : (i===1 ? "badge2":""));
      tile.textContent = tileToStr(it.tile);
      tile.title = tileToKey(it.tile);
      const text = document.createElement("div");
      text.innerHTML = `<b>${tileToKey(it.tile)}</b><div class="smeta">åˆ‡ã‚Šå¾Œ ã‚·ãƒ£ãƒ³ãƒ†ãƒ³ ${it.shanten} ï¼ å—ã‘å…¥ã‚Œ ${it.ukeire}æš</div>`;
      left.appendChild(tile);
      left.appendChild(text);

      const right = document.createElement("div");
      right.className = "pill";
      right.innerHTML = i===0 ? `<strong style="color:var(--good)">æœ€å–„</strong>` : (i===1 ? `<strong style="color:var(--warn)">æ¬¡ç‚¹</strong>` : `å€™è£œ`);

      row.appendChild(left);
      row.appendChild(right);
      els.bestList.appendChild(row);
    }
  }else{
    els.bestList.innerHTML = `<div class="muted">è©•ä¾¡ä¸­â€¦</div>`;
  }

  // render hand clickable
  els.myHand.innerHTML = "";
  const bestTile = evals.length ? evals[0].tile : null;

  // To make duplicates clickable separately, we render each tile, but highlight if equals bestTile.
  for(let i=0;i<tiles.length;i++){
    const t = tiles[i];
    const sp = document.createElement("span");
    sp.className = "tile clickable" + (t===bestTile ? " best" : "");
    sp.textContent = tileToStr(t);
    sp.title = `${tileToKey(t)}ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§æ‰“ç‰Œï¼‰`;
    sp.addEventListener("click", ()=>{
      if(STATE.ended) return;
      if(STATE.turn !== 0) return;
      if(!STATE.waitingHuman) return;
      humanDiscardAtIndex(i);
    });
    els.myHand.appendChild(sp);
  }
}

function initGame(){
  STATE.ended = false;
  STATE.auto = false;
  STATE.waitingHuman = false;

  // build wall 136 tiles
  const wall = [];
  for(let t=0;t<34;t++){
    for(let k=0;k<4;k++) wall.push(t);
  }
  shuffle(wall);
  STATE.wall = wall;

  STATE.hands = [[],[],[],[]];
  STATE.rivers = [[],[],[],[]];

  // deal: each 13, dealer 14 (we set dealer = 0)
  for(let r=0;r<13;r++){
    for(let p=0;p<4;p++){
      STATE.hands[p].push(STATE.wall.pop());
    }
  }
  // dealer draw extra
  STATE.hands[0].push(STATE.wall.pop());

  for(let p=0;p<4;p++) sortHandTiles(STATE.hands[p]);
  STATE.turn = 0;

  els.log.innerHTML = "";
  logLine(`<b>æ–°è¦é–‹å§‹</b>ï¼šé…ç‰Œã—ã¾ã—ãŸï¼ˆã‚ãªãŸã¯14æšï¼‰ã€‚`);
  setStatus(`ã‚ãªãŸã®æ‰‹ç•ªã§ã™ã€‚æœ€å–„æ‰‹ã‚’å‚è€ƒã«ã€æ‰‹ç‰Œã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦1æšåˆ‡ã£ã¦ãã ã•ã„ã€‚`);

  renderPlayers();
  renderTop();
  renderMyHand();

  // check immediate win (rare)
  if(isAgari(countsFromTiles(STATE.hands[0]))){
    endGame(`ã‚ãªãŸã®é…ç‰ŒãŒå’Œäº†å½¢ã§ã—ãŸï¼ˆå½¹åˆ¤å®šãªã—ã®ãŸã‚å³å’Œäº†æ‰±ã„ï¼‰ã€‚`);
  }else{
    STATE.waitingHuman = true;
  }
}

function endGame(message){
  STATE.ended = true;
  STATE.waitingHuman = false;
  setStatus(`<strong>çµ‚äº†ï¼š</strong>${message}`);
  logLine(`<b>çµ‚äº†</b>ï¼š${message}`);
  renderPlayers(); renderTop(); renderMyHand();
}

function drawTile(p){
  if(STATE.wall.length <= 0) return null;
  const t = STATE.wall.pop();
  STATE.hands[p].push(t);
  return t;
}

function discardTile(p, tile){
  // remove one instance of tile from hand
  const hand = STATE.hands[p];
  const idx = hand.indexOf(tile);
  if(idx>=0) hand.splice(idx,1);
  STATE.rivers[p].push(tile);
}

function cpuChooseDiscard(p){
  const tiles = STATE.hands[p].slice();
  sortHandTiles(tiles);
  const rem = remainingCountsFromWall(STATE.wall);
  const evals = evaluateDiscards(tiles, rem);
  // choose best
  const chosen = evals.length ? evals[0].tile : tiles[0];
  return {chosen, evals};
}

function advanceTurn(){
  if(STATE.ended) return;

  const p = STATE.turn;

  // if wall empty => draw
  if(STATE.wall.length <= 0){
    endGame("å±±ãŒå°½ãã¾ã—ãŸï¼ˆæµå±€ï¼‰ã€‚");
    return;
  }

  // draw
  const drawn = drawTile(p);
  sortHandTiles(STATE.hands[p]);

  // win check (tsumo only, ron not implemented)
  const c = countsFromTiles(STATE.hands[p]);
  if(isAgari(c)){
    endGame(`${PLAYERS[p].name} ãŒãƒ„ãƒ¢å’Œäº†ã—ã¾ã—ãŸï¼ˆå½¹åˆ¤å®šãªã—ï¼‰ã€‚`);
    return;
  }

  if(p === 0){
    // human
    renderPlayers(); renderTop(); renderMyHand();
    STATE.waitingHuman = true;
    setStatus(`ã‚ãªãŸãŒ <b>${tileToStr(drawn)}ï¼ˆ${tileToKey(drawn)}ï¼‰</b> ã‚’ãƒ„ãƒ¢ã€‚æ‰‹ç‰Œã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦1æšåˆ‡ã£ã¦ãã ã•ã„ã€‚`);
    logLine(`ã‚ãªãŸãŒãƒ„ãƒ¢ï¼š${tileToStr(drawn)}ï¼ˆ${tileToKey(drawn)}ï¼‰`);
    return;
  }else{
    // CPU: pick discard
    const {chosen, evals} = cpuChooseDiscard(p);
    discardTile(p, chosen);

    const top = evals && evals.length ? evals[0] : null;
    logLine(`${PLAYERS[p].name} ãƒ„ãƒ¢ï¼š${tileToStr(drawn)} â†’ æ‰“ï¼š${tileToStr(chosen)}ï¼ˆæœ€å–„: ã‚·ãƒ£ãƒ³ãƒ†ãƒ³${top?top.shanten:"?"}/å—å…¥${top?top.ukeire:"?"}ï¼‰`);

    // next
    STATE.turn = (STATE.turn + 1) % 4;
    renderPlayers(); renderTop(); renderMyHand();

    // continue automatically if auto on and next isn't human
    if(STATE.auto && STATE.turn !== 0 && !STATE.ended){
      setTimeout(advanceTurn, msDelay());
    }else if(STATE.turn === 0 && !STATE.ended){
      // human's draw happens on their turn start by stepping
      setStatus(`ã‚ãªãŸã®ç•ªã§ã™ã€‚ã€Œæ¬¡ã¸ã€ã‹è‡ªå‹•ONã§ãƒ„ãƒ¢ã—ã¾ã™ã€‚`);
      STATE.waitingHuman = false;
    }else{
      setStatus(`${PLAYERS[STATE.turn].name} ã®ç•ªã§ã™ã€‚`);
    }
  }
}

function humanDiscardAtIndex(sortedIndexInRender){
  // Render uses sorted copy; we should discard that tile from actual hand by value, removing one instance.
  const hand = STATE.hands[0].slice();
  sortHandTiles(hand);
  const tile = hand[sortedIndexInRender];

  // show best calculation now (for log)
  const rem = remainingCountsFromWall(STATE.wall);
  const evals = evaluateDiscards(hand, rem);
  const best = evals.length ? evals[0] : null;

  discardTile(0, tile);
  STATE.waitingHuman = false;

  logLine(`ã‚ãªãŸã®æ‰“ç‰Œï¼š${tileToStr(tile)}ï¼ˆ${tileToKey(tile)}ï¼‰` + (best ? ` ï¼ æœ€å–„ã¯ ${tileToStr(best.tile)}ï¼ˆã‚·ãƒ£ãƒ³ãƒ†ãƒ³${best.shanten}/å—å…¥${best.ukeire}ï¼‰` : ""));

  // after discard, move to next player and auto-run
  STATE.turn = 1;
  renderPlayers(); renderTop(); renderMyHand();

  if(STATE.auto && !STATE.ended){
    setTimeout(advanceTurn, msDelay());
  }else{
    setStatus(`${PLAYERS[STATE.turn].name} ã®ç•ªã§ã™ã€‚ã€Œæ¬¡ã¸ã€ã§é€²ã¿ã¾ã™ã€‚`);
  }
}

/** ===========================
 *  Buttons
 * =========================== */
els.btnNew.addEventListener("click", ()=>{
  initGame();
  els.btnAuto.textContent = "è‡ªå‹•ï¼šOFF";
  els.btnAuto.classList.add("danger");
  STATE.auto = false;
});

els.btnStep.addEventListener("click", ()=>{
  if(STATE.ended) return;
  // if it's human turn and waiting discard => do nothing
  if(STATE.turn === 0 && STATE.waitingHuman){
    setStatus("ã‚ãªãŸã®æ‰‹ç•ªã§ã™ã€‚æ‰‹ç‰Œã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ‰“ç‰Œã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  // if it's human turn but not yet drawn => draw+discard waiting in advanceTurn
  if(STATE.turn === 0 && !STATE.waitingHuman){
    advanceTurn(); // draw for human
    return;
  }
  // CPU turn => just advance
  advanceTurn();
});

els.btnAuto.addEventListener("click", ()=>{
  if(STATE.ended) return;
  STATE.auto = !STATE.auto;
  els.btnAuto.textContent = STATE.auto ? "è‡ªå‹•ï¼šON" : "è‡ªå‹•ï¼šOFF";
  els.btnAuto.classList.toggle("danger", !STATE.auto);
  if(STATE.auto){
    // run if currently CPU turn
    if(STATE.turn !== 0 && !STATE.ended){
      setTimeout(advanceTurn, msDelay());
    }
  }
});

// initial render shell
renderPlayers(); renderTop(); renderMyHand();
els.btnAuto.classList.add("danger");
</script>
</body>
</html>
